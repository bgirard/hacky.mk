diff --git a/config/rules.mk b/config/rules.mk
--- a/config/rules.mk
+++ b/config/rules.mk
@@ -966,25 +966,37 @@ else
 endif
 endif
 
 ifdef DTRACE_PROBE_OBJ
 EXTRA_DEPS += $(DTRACE_PROBE_OBJ)
 OBJS += $(DTRACE_PROBE_OBJ)
 endif
 
-$(filter %.$(LIB_SUFFIX),$(LIBRARY)): $(OBJS) $(LOBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(filter %.$(LIB_SUFFIX),$(LIBRARY)): $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(RM) $(LIBRARY)
-	$(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(LOBJS) $(SHARED_LIBRARY_LIBS)
+	$(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS)
 	$(RANLIB) $@
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(OBJS) $(EXTRA_DEPS)" \
+		"$(RM) $(LIBRARY) && $(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS) && $(RANLIB) $@"
 
-$(filter-out %.$(LIB_SUFFIX),$(LIBRARY)): $(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(LOBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(filter-out %.$(LIB_SUFFIX),$(LIBRARY)): $(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 # When we only build a library descriptor, blow out any existing library
 	$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY)))
-	$(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(LOBJS) $(SHARED_LIBRARY_LIBS)
+	$(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS)" \
+		"$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),true,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY))) && $(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)"
 
 ifeq ($(OS_ARCH),WINNT)
 # Import libraries are created by the rules creating shared libraries.
 # The rules to copy them to $(DIST)/lib depend on $(IMPORT_LIBRARY),
 # but make will happily consider the import library before it is refreshed
 # when rebuilding the corresponding shared library. Defining an empty recipe
 # for import libraries forces make to wait for the shared library recipe to
 # have run before considering other targets that depend on the import library.
@@ -1026,30 +1038,37 @@ endif
 endif
 endif
 
 # On Darwin (Mac OS X), dwarf2 debugging uses debug info left in .o files,
 # so instead of deleting .o files after repacking them into a dylib, we make
 # symlinks back to the originals. The symlinks are a no-op for stabs debugging,
 # so no need to conditionalize on OS version or debugging format.
 
-$(SHARED_LIBRARY): $(OBJS) $(LOBJS) $(DEF_FILE) $(RESFILE) $(LIBRARY) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(SHARED_LIBRARY): $(OBJS) $(DEF_FILE) $(RESFILE) $(LIBRARY) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(info $(notdir $@))
 ifndef INCREMENTAL_LINKER
 	$(RM) $@
 endif
 ifdef DTRACE_LIB_DEPENDENT
 ifndef XP_MACOSX
 	dtrace -G -C -s $(MOZILLA_DTRACE_SRC) -o  $(DTRACE_PROBE_OBJ) $(shell $(EXPAND_LIBS) $(MOZILLA_PROBE_LIBS))
 endif
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+endif
+	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+ifdef DTRACE_LIB_DEPENDENT
 	@$(RM) $(DTRACE_PROBE_OBJ)
-else # ! DTRACE_LIB_DEPENDENT
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
-endif # DTRACE_LIB_DEPENDENT
+endif
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(subst ",^^,$(OBJS)) $(subst ",^^,$(DEF_FILE)) $(subst ",^^,$(LIBRARY)) $(subst ",^^,$(EXTRA_DEPS))" \
+		"$(EXPAND_MKSHLIB) $(subst ",^^,$(SHLIB_LDSTARTFILE)) $(subst ",^^,$(OBJS)) $(subst ",^^,$(SUB_SHLOBJS)) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS)  $(subst ",^^,$(RESFILE)) $(subst ",^^,$(LDFLAGS)) $(subst ",^^,$(WRAP_LDFLAGS)) $(subst ",^^,$(SHARED_LIBRARY_LIBS))  $(subst ",^^,$(EXTRA_DSO_LDOPTS))  $(subst ",^^,$(MOZ_GLUE_LDFLAGS)) $(subst ",^^,$(OS_LIBS)) $(subst ",^^,$(EXTRA_LIBS)) $(subst ",^^,$(DEF_FILE)) $(subst ",^^,$(SHLIB_LDENDFILE)) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))" \
+		"$(MDDEPDIR)/$(@F).pp"
 	@$(call CHECK_STDCXX,$@)
 
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 ifdef MSMANIFEST_TOOL
 ifdef EMBED_MANIFEST_AT
 	@if test -f $@.manifest; then \
 		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;$(EMBED_MANIFEST_AT); \
 		rm -f $@.manifest; \
@@ -1120,16 +1139,26 @@ endef
 $(HOST_CMMOBJS): host_%.$(OBJ_SUFFIX): %.mm
 	$(REPORT_BUILD)
 	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(HOST_CMMFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
 
 $(COBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 # DEFINES and ACDEFINES are needed here to enable conditional compilation of Q_OBJECTs:
 # 'moc' only knows about #defines it gets on the command line (-D...), not in
 # included headers like mozilla-config.h
 moc_%.cpp: %.h
 	$(ELOG) $(MOC) $(DEFINES) $(ACDEFINES) $< $(OUTOPTION)$@
 
 moc_%.cc: %.cc
@@ -1147,26 +1176,56 @@ endif
 
 $(SOBJS):
 	$(AS) -o $@ $(ASFLAGS) $(LOCAL_INCLUDES) $(TARGET_LOCAL_INCLUDES) -c $<
 
 $(CPPOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) -o $@ -c $(COMPILE_CXXFLAGS) $(COMPILE_CMMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS)) $(subst ",^^,$(COMPILE_CMMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) -o $@ -c $(COMPILE_CFLAGS) $(COMPILE_CMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS)) $(subst ",^^,$(COMPILE_CMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 %.s: %.cpp $(call mkdir_deps,$(MDDEPDIR))
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
 
 %.s: %.cc $(call mkdir_deps,$(MDDEPDIR))
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
 
 %.s: %.c $(call mkdir_deps,$(MDDEPDIR))
@@ -1719,17 +1778,17 @@ endif
 #
 # The INSTALL_TARGETS variable contains a list of all install target
 # categories. Each category defines a list of files and executables, and an
 # install destination,
 #
 # FOO_FILES := foo bar
 # FOO_EXECUTABLES := baz
 # FOO_DEST := target_path
-# INSTALL_TARGETS += FOO
+#I NSTALL_TARGETS += FOO
 #
 # Additionally, a FOO_TARGET variable may be added to indicate the target for
 # which the files and executables are installed. Default is "libs".
 
 # If we're using binary nsinstall and it's not built yet, fallback to python nsinstall.
 ifneq (,$(filter $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX),$(install_cmd)))
 ifeq (,$(wildcard $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX)))
 nsinstall_is_usable = $(if $(wildcard $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX)),yes)
@@ -1740,24 +1799,25 @@ endef
 endif
 endif
 
 define install_file_template
 $(or $(3),libs):: $(2)/$(notdir $(1))
 $(call install_cmd_override,$(2)/$(notdir $(1)))
 $(2)/$(notdir $(1)): $(1)
 	$$(call install_cmd,$(4) "$$<" "$${@D}")
+	$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py install "$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" "$(category)" "$$<" "$${@D}"
 endef
 $(foreach category,$(INSTALL_TARGETS),\
   $(if $($(category)_DEST),,$(error Missing $(category)_DEST))\
   $(foreach file,$($(category)_FILES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1),$(category)))\
   )\
   $(foreach file,$($(category)_EXECUTABLES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2),$(category)))\
   )\
 )
 
 ################################################################################
 # Preprocessing rules
 #
 # The PP_TARGETS variable contains a list of all preprocessing target
 # categories. Each category has associated variables listing input files, the
diff --git a/js/src/config/rules.mk b/js/src/config/rules.mk
--- a/js/src/config/rules.mk
+++ b/js/src/config/rules.mk
@@ -966,25 +966,37 @@ else
 endif
 endif
 
 ifdef DTRACE_PROBE_OBJ
 EXTRA_DEPS += $(DTRACE_PROBE_OBJ)
 OBJS += $(DTRACE_PROBE_OBJ)
 endif
 
-$(filter %.$(LIB_SUFFIX),$(LIBRARY)): $(OBJS) $(LOBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(filter %.$(LIB_SUFFIX),$(LIBRARY)): $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(RM) $(LIBRARY)
-	$(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(LOBJS) $(SHARED_LIBRARY_LIBS)
+	$(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS)
 	$(RANLIB) $@
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(OBJS) $(EXTRA_DEPS)" \
+		"$(RM) $(LIBRARY) && $(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS) && $(RANLIB) $@"
 
-$(filter-out %.$(LIB_SUFFIX),$(LIBRARY)): $(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(LOBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(filter-out %.$(LIB_SUFFIX),$(LIBRARY)): $(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 # When we only build a library descriptor, blow out any existing library
 	$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY)))
-	$(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(LOBJS) $(SHARED_LIBRARY_LIBS)
+	$(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS)" \
+		"$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),true,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY))) && $(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)"
 
 ifeq ($(OS_ARCH),WINNT)
 # Import libraries are created by the rules creating shared libraries.
 # The rules to copy them to $(DIST)/lib depend on $(IMPORT_LIBRARY),
 # but make will happily consider the import library before it is refreshed
 # when rebuilding the corresponding shared library. Defining an empty recipe
 # for import libraries forces make to wait for the shared library recipe to
 # have run before considering other targets that depend on the import library.
@@ -1026,30 +1038,37 @@ endif
 endif
 endif
 
 # On Darwin (Mac OS X), dwarf2 debugging uses debug info left in .o files,
 # so instead of deleting .o files after repacking them into a dylib, we make
 # symlinks back to the originals. The symlinks are a no-op for stabs debugging,
 # so no need to conditionalize on OS version or debugging format.
 
-$(SHARED_LIBRARY): $(OBJS) $(LOBJS) $(DEF_FILE) $(RESFILE) $(LIBRARY) $(EXTRA_DEPS) $(GLOBAL_DEPS)
+$(SHARED_LIBRARY): $(OBJS) $(DEF_FILE) $(RESFILE) $(LIBRARY) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(info $(notdir $@))
 ifndef INCREMENTAL_LINKER
 	$(RM) $@
 endif
 ifdef DTRACE_LIB_DEPENDENT
 ifndef XP_MACOSX
 	dtrace -G -C -s $(MOZILLA_DTRACE_SRC) -o  $(DTRACE_PROBE_OBJ) $(shell $(EXPAND_LIBS) $(MOZILLA_PROBE_LIBS))
 endif
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+endif
+	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+ifdef DTRACE_LIB_DEPENDENT
 	@$(RM) $(DTRACE_PROBE_OBJ)
-else # ! DTRACE_LIB_DEPENDENT
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(LOBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
-endif # DTRACE_LIB_DEPENDENT
+endif
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(OBJS) $(DEF_FILE) $(LIBRARY) $(EXTRA_DEPS)" \
+		"$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))" \
+		"$(MDDEPDIR)/$(@F).pp"
 	@$(call CHECK_STDCXX,$@)
 
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 ifdef MSMANIFEST_TOOL
 ifdef EMBED_MANIFEST_AT
 	@if test -f $@.manifest; then \
 		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;$(EMBED_MANIFEST_AT); \
 		rm -f $@.manifest; \
@@ -1120,16 +1139,26 @@ endef
 $(HOST_CMMOBJS): host_%.$(OBJ_SUFFIX): %.mm
 	$(REPORT_BUILD)
 	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(HOST_CMMFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
 
 $(COBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 # DEFINES and ACDEFINES are needed here to enable conditional compilation of Q_OBJECTs:
 # 'moc' only knows about #defines it gets on the command line (-D...), not in
 # included headers like mozilla-config.h
 moc_%.cpp: %.h
 	$(ELOG) $(MOC) $(DEFINES) $(ACDEFINES) $< $(OUTOPTION)$@
 
 moc_%.cc: %.cc
@@ -1147,26 +1176,56 @@ endif
 
 $(SOBJS):
 	$(AS) -o $@ $(ASFLAGS) $(LOCAL_INCLUDES) $(TARGET_LOCAL_INCLUDES) -c $<
 
 $(CPPOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) -o $@ -c $(COMPILE_CXXFLAGS) $(COMPILE_CMMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS)) $(subst ",^^,$(COMPILE_CMMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) -o $@ -c $(COMPILE_CFLAGS) $(COMPILE_CMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS)) $(subst ",^^,$(COMPILE_CMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 %.s: %.cpp $(call mkdir_deps,$(MDDEPDIR))
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
 
 %.s: %.cc $(call mkdir_deps,$(MDDEPDIR))
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
 
 %.s: %.c $(call mkdir_deps,$(MDDEPDIR))
@@ -1719,17 +1778,17 @@ endif
 #
 # The INSTALL_TARGETS variable contains a list of all install target
 # categories. Each category defines a list of files and executables, and an
 # install destination,
 #
 # FOO_FILES := foo bar
 # FOO_EXECUTABLES := baz
 # FOO_DEST := target_path
-# INSTALL_TARGETS += FOO
+#I NSTALL_TARGETS += FOO
 #
 # Additionally, a FOO_TARGET variable may be added to indicate the target for
 # which the files and executables are installed. Default is "libs".
 
 # If we're using binary nsinstall and it's not built yet, fallback to python nsinstall.
 ifneq (,$(filter $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX),$(install_cmd)))
 ifeq (,$(wildcard $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX)))
 nsinstall_is_usable = $(if $(wildcard $(CONFIG_TOOLS)/nsinstall$(HOST_BIN_SUFFIX)),yes)
@@ -1740,24 +1799,25 @@ endef
 endif
 endif
 
 define install_file_template
 $(or $(3),libs):: $(2)/$(notdir $(1))
 $(call install_cmd_override,$(2)/$(notdir $(1)))
 $(2)/$(notdir $(1)): $(1)
 	$$(call install_cmd,$(4) "$$<" "$${@D}")
+	$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py install "$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" "$(category)" "$$<" "$${@D}"
 endef
 $(foreach category,$(INSTALL_TARGETS),\
   $(if $($(category)_DEST),,$(error Missing $(category)_DEST))\
   $(foreach file,$($(category)_FILES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1),$(category)))\
   )\
   $(foreach file,$($(category)_EXECUTABLES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2),$(category)))\
   )\
 )
 
 ################################################################################
 # Preprocessing rules
 #
 # The PP_TARGETS variable contains a list of all preprocessing target
 # categories. Each category has associated variables listing input files, the
