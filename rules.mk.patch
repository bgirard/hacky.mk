diff --git a/config/rules.mk b/config/rules.mk
--- a/config/rules.mk
+++ b/config/rules.mk
@@ -863,16 +863,25 @@ alltags:
 # PROGRAM = Foo
 # creates OBJS, links with LIBS to create Foo
 #
 $(PROGRAM): $(PROGOBJS) $(EXTRA_DEPS) $(EXE_DEF_FILE) $(RESFILE) $(GLOBAL_DEPS)
 	$(REPORT_BUILD)
 	@$(RM) $@.manifest
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 	$(EXPAND_LD) -NOLOGO -OUT:$@ -PDB:$(LINK_PDBFILE) $(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(MOZ_GLUE_PROGRAM_LDFLAGS) $(PROGOBJS) $(RESFILE) $(LIBS) $(EXTRA_LIBS) $(OS_LIBS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py program-win32 \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(WIN32_EXE_LDFLAGS) $(LDFLAGS) $(MOZ_GLUE_PROGRAM_LDFLAGS)" \
+		"$(PROGOBJS) $(RESFILE)" \
+		"$(LIBS) $(EXTRA_LIBS) $(OS_LIBS)" \
+		"$(LINK_PDBFILE)" \
+		"$(EXPAND_LD)"
 ifdef MSMANIFEST_TOOL
 	@if test -f $@.manifest; then \
 		if test -f "$(srcdir)/$@.manifest"; then \
 			echo "Embedding manifest from $(srcdir)/$@.manifest and $@.manifest"; \
 			mt.exe -NOLOGO -MANIFEST "$(win_srcdir)/$@.manifest" $@.manifest -OUTPUTRESOURCE:$@\;1; \
 		else \
 			echo "Embedding manifest from $@.manifest"; \
 			mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;1; \
@@ -972,22 +981,36 @@ EXTRA_DEPS += $(DTRACE_PROBE_OBJ)
 OBJS += $(DTRACE_PROBE_OBJ)
 endif
 
 $(filter %.$(LIB_SUFFIX),$(LIBRARY)): $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(REPORT_BUILD)
 	$(RM) $(LIBRARY)
 	$(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS)
 	$(RANLIB) $@
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(OBJS) $(EXTRA_DEPS)" \
+		"$(RM) $(LIBRARY) && $(EXPAND_AR) $(AR_FLAGS) $(OBJS) $(SHARED_LIBRARY_LIBS) && $(RANLIB) $@" \
+		""
 
 $(filter-out %.$(LIB_SUFFIX),$(LIBRARY)): $(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 # When we only build a library descriptor, blow out any existing library
 	$(REPORT_BUILD)
 	$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY)))
 	$(EXPAND_LIBS_GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(filter %.$(LIB_SUFFIX),$(LIBRARY)) $(OBJS) $(EXTRA_DEPS)" \
+		"$(if $(filter %.$(LIB_SUFFIX),$(LIBRARY)),true,$(RM) $(REAL_LIBRARY) $(EXPORT_LIBRARY:%=%/$(REAL_LIBRARY))) && $(EXPAND_LIBS    _GEN) -o $@ $(OBJS) $(SHARED_LIBRARY_LIBS)" \
+		""
 
 ifeq ($(OS_ARCH),WINNT)
 # Import libraries are created by the rules creating shared libraries.
 # The rules to copy them to $(DIST)/lib depend on $(IMPORT_LIBRARY),
 # but make will happily consider the import library before it is refreshed
 # when rebuilding the corresponding shared library. Defining an empty recipe
 # for import libraries forces make to wait for the shared library recipe to
 # have run before considering other targets that depend on the import library.
@@ -1039,24 +1062,34 @@ endif
 $(SHARED_LIBRARY): $(OBJS) $(DEF_FILE) $(RESFILE) $(LIBRARY) $(EXTRA_DEPS) $(GLOBAL_DEPS)
 	$(REPORT_BUILD)
 ifndef INCREMENTAL_LINKER
 	$(RM) $@
 endif
 ifdef DTRACE_LIB_DEPENDENT
 ifndef XP_MACOSX
 	dtrace -G -C -s $(MOZILLA_DTRACE_SRC) -o  $(DTRACE_PROBE_OBJ) $(shell $(EXPAND_LIBS) $(MOZILLA_PROBE_LIBS))
+	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
 endif
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(DTRACE_PROBE_OBJ) $(MOZILLA_PROBE_LIBS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+endif
+	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
+ifdef DTRACE_LIB_DEPENDENT
 	@$(RM) $(DTRACE_PROBE_OBJ)
-else # ! DTRACE_LIB_DEPENDENT
-	$(EXPAND_MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(WRAP_LDFLAGS) $(SHARED_LIBRARY_LIBS) $(EXTRA_DSO_LDOPTS) $(MOZ_GLUE_LDFLAGS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))
-endif # DTRACE_LIB_DEPENDENT
+endif
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(subst ",^^,$(OBJS)) $(subst ",^^,$(DEF_FILE)) $(subst ",^^,$(LIBRARY)) $(subst ",^^,$(EXTRA_DEPS))" \
+		"$(EXPAND_MKSHLIB) $(subst ",^^,$(SHLIB_LDSTARTFILE)) $(subst ",^^,$(OBJS)) $(subst ",^^,$(SUB_SHLOBJS)) $(DTRACE_PROBE_OBJ)     $(MOZILLA_PROBE_LIBS)  $(subst ",^^,$(RESFILE)) $(subst ",^^,$(LDFLAGS)) $(subst ",^^,$(WRAP_LDFLAGS)) $(subst ",^^,$(SHARED_LIBRAR    Y_LIBS))  $(subst ",^^,$(EXTRA_DSO_LDOPTS))  $(subst ",^^,$(MOZ_GLUE_LDFLAGS)) $(subst ",^^,$(OS_LIBS)) $(subst ",^^,$(EXTRA_LIBS))     $(subst ",^^,$(DEF_FILE)) $(subst ",^^,$(SHLIB_LDENDFILE)) $(if $(LIB_IS_C_ONLY),,$(STLPORT_LIBS))" \
+		$(IMPORT_LIBRARY) \
+		"$(MDDEPDIR)/$(@F).pp"
 	@$(call CHECK_STDCXX,$@)
 
+
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 ifdef MSMANIFEST_TOOL
 ifdef EMBED_MANIFEST_AT
 	@if test -f $@.manifest; then \
 		mt.exe -NOLOGO -MANIFEST $@.manifest -OUTPUTRESOURCE:$@\;$(EMBED_MANIFEST_AT); \
 		rm -f $@.manifest; \
 	fi
 endif   # EMBED_MANIFEST_AT
@@ -1125,16 +1158,26 @@ endef
 $(HOST_CMMOBJS): host_%.$(OBJ_SUFFIX): %.mm
 	$(REPORT_BUILD)
 	$(ELOG) $(HOST_CXX) $(HOST_OUTOPTION)$@ -c $(HOST_CXXFLAGS) $(HOST_CMMFLAGS) $(INCLUDES) $(NSPR_CFLAGS) $(_VPATH_SRCS)
 
 $(COBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 # DEFINES and ACDEFINES are needed here to enable conditional compilation of Q_OBJECTs:
 # 'moc' only knows about #defines it gets on the command line (-D...), not in
 # included headers like mozilla-config.h
 moc_%.cpp: %.h
 	$(REPORT_BUILD)
 	$(ELOG) $(MOC) $(DEFINES) $(ACDEFINES) $< $(OUTOPTION)$@
 
@@ -1157,26 +1200,56 @@ endif
 $(SOBJS):
 	$(REPORT_BUILD)
 	$(AS) -o $@ $(ASFLAGS) $(LOCAL_INCLUDES) $(TARGET_LOCAL_INCLUDES) -c $<
 
 $(CPPOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CXX)
 	$(ELOG) $(CCC) -o $@ -c $(COMPILE_CXXFLAGS) $(COMPILE_CMMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CXXFLAGS)) $(subst ",^^,$(COMPILE_CMMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 $(CMOBJS):
 	$(REPORT_BUILD)
 	@$(MAKE_DEPS_AUTO_CC)
 	$(ELOG) $(CC) -o $@ -c $(COMPILE_CFLAGS) $(COMPILE_CMFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
+	@$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py cc \
+		"$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" \
+		"$(realpath .)" \
+		"$@" \
+		"$(_VPATH_SRCS)" \
+		"$(CCC)" \
+		"$(OUTOPTION)" \
+		"$(subst ",^^,$(COMPILE_CFLAGS)) $(subst ",^^,$(COMPILE_CMFLAGS))" \
+		"$(subst ",^^,$(TARGET_LOCAL_INCLUDES))" \
+		"$(MDDEPDIR)/$(@F).pp"
 
 %.s: %.cpp $(call mkdir_deps,$(MDDEPDIR))
 	$(REPORT_BUILD)
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
 
 %.s: %.cc $(call mkdir_deps,$(MDDEPDIR))
 	$(REPORT_BUILD)
 	$(CCC) -S $(COMPILE_CXXFLAGS) $(TARGET_LOCAL_INCLUDES) $(_VPATH_SRCS)
@@ -1760,24 +1833,25 @@ endef
 endif
 endif
 
 define install_file_template
 $(or $(3),libs):: $(2)/$(notdir $(1))
 $(call install_cmd_override,$(2)/$(notdir $(1)))
 $(2)/$(notdir $(1)): $(1)
 	$$(call install_cmd,$(4) "$$<" "$${@D}")
+	$(PYTHON) $(topsrcdir)/tools/hackymake/makehacky.py install "$(if $(TOP_DIST),$(TOP_DIST)/..,$(DEPTH))" "$(category)" "$$<" "$${@D}"
 endef
 $(foreach category,$(INSTALL_TARGETS),\
   $(if $($(category)_DEST),,$(error Missing $(category)_DEST))\
   $(foreach file,$($(category)_FILES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS1),$(category)))\
   )\
   $(foreach file,$($(category)_EXECUTABLES),\
-    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2)))\
+    $(eval $(call install_file_template,$(file),$($(category)_DEST),$($(category)_TARGET),$(IFLAGS2),$(category)))\
   )\
 )
 
 ################################################################################
 # Preprocessing rules
 #
 # The PP_TARGETS variable contains a list of all preprocessing target
 # categories. Each category has associated variables listing input files, the
